# 1주차 DFS(Depth-First Search) 이론 정리 및 개념 정리

## 1. 재귀 DFS vs 스택 DFS 장단점

- **재귀 호출로 구현한 DFS**는 코드가 직관적이어서 개인적으로 구현하기가 쉽게 느껴진다.  
  하지만 함수를 계속 호출하는 방식인 만큼, 호출 횟수가 많아질 경우 **스택 오버플로우**를 고려해야 한다.  
  인터넷에서 찾아본 결과, 일반적으로 호출 횟수가 **100,000번(십만)**을 넘을 경우 런타임 오류가 발생할 수 있다.

- **스택을 사용한 DFS**는 재귀 방식보다는 덜 직관적일 수 있지만,  
  **스택 오버플로우에 대한 위험이 없기 때문에** 큰 입력에서도 안정적으로 사용할 수 있다는 장점이 있다.

---

## 2. 방향 그래프에서 싸이클의 존재를 확인하는 방법

- DFS 탐색 중에 **이미 방문한 노드를 재방문하는 경우**, 싸이클이 존재한다고 볼 수 있다.
- 일반적으로 `visited`라는 벡터를 사용해 노드 방문 여부를 체크하고,  
  동시에 `path`(또는 `onPath`)라는 벡터를 사용해 **현재 DFS 경로상에 포함된 노드인지**를 추적한다.
- 만약 DFS 중에 다음 노드가 `visited`는 되어 있고, 동시에 `path` 상에도 존재한다면,  
  이는 **싸이클이 존재하는 경우**로 판단할 수 있다.

---

## 3. 백트래킹의 개념

- DFS에서 **가장 깊은 노드까지 탐색한 후**, 더 이상 진행할 수 없거나 조건을 만족하지 않으면  
  **직전 노드로 돌아가 다른 방향을 탐색하는 것**을 **백트래킹(backtracking)**이라고 한다.

### 백트래킹 예시 코드 (재귀 DFS)

```cpp
void dfs(int node) {
    visited[node] = true;

    for (int i = 0; i < graph[node].size(); i++) {
        int next = graph[node][i];
        if (!visited[next]) {
            dfs(next);
        }
    }
}
```
